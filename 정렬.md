![Untitled](https://user-images.githubusercontent.com/76994457/124481161-f6ece600-dde2-11eb-927f-f2d4dc24d7a2.png)
# 정렬


## 선택 정렬

- [ ]  선택 정렬은 이름에 맞게 현재 위치에 들어갈 값을 찾아 정렬하는 배열이다.
- [ ]  시간 복잡도:n^2

```cpp
void selectionSort(int arr[], int size) {
    int minIndex;
    int i, j;
    for (i = 0; i < size - 1; i++) {
        minIndex = i;
        for (j = i + 1; j < size; j++) 
            if (arr[j] < arr[minIndex])
                minIndex = j;
         
        swap(arr[i], arr[minIndex]);
    }
}
```

## 버블 정렬

- [ ]  현재 배열 요소와 그 다음 배열 요소를 비교해서 교환하는 식의 정렬이다.
- [ ]  시간 복잡도:n^2

```cpp
void bubbleSort(int arr[], int size) {
    int i, j;
    for (i = size - 1; i>0; i--) 
        for (j = 0; j<i; j++) 
            if (arr[j]<arr[j + 1]) 
                swap(arr[j],arr[j + 1]);
}
```

## 삽입 정렬

- [ ]  key값을 정하고 key보다 큰 값을 하나 하나씩 밀어버리고 key보다 작은 값을 만났을때 그 뒷자리에 삽입하는 것입니다.
- [ ]  시간 복잡도:n^2

```cpp
void insertionSort(int arr[], int size) {
    int i, j,key;
 
    for (i = 1; i < size; i++) {
        key = arr[i];
        j = i - 1;
        while (j >= 0&&arr[j]>key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```

## 병합 정렬

- [ ]  주어진 수열을 가운데에서 쪼개 비슷한 크기의 수열 두개로 만든 뒤 이들을 재귀 호출을 이용해 각각 정렬한 후 정렬된 배열을 하나로 합치는 방식
- [ ]  시간복잡도:nlogn

```cpp
int sorted[100];
 
void mergesort(int list[], int left, int right){
  int mid;
 
  if (left < right){
    mid = (left + right) / 2; //중간 위치를 계산하여 리스트를 균등 분할 - Divide(분할)
    mergesort(list, left, mid);  //앞쪽 부분 리스트 정렬 - Conquer (정복)
    mergesort(list, mid+1, right); //뒤쪽 부분 리스트 정렬 - Conquer (정복)
    merge(list, left, mid, right); //정렬된 2개의 부분 배열을 합병하는 과정 - Combine (결합)
  }
}
 
void merge(int list[], int left, int mid, int right){
  int i, j, k, l;
  i = left; j = mid+1; k = left;
 
  //분할 정렬된 list 합병
  while(i <= mid && j <= right){
    if(list[i] <= list[j]){
      sorted[k] = list[i];
      k++; i++;
    {
    else{
      sorted[k] = list[j];
      k++; j++;
    }
  }
 
  //남아있는 값들을 일괄 복사
  if(i>mid){
    for(l=j; l<=right; l++){
      sorted[k] = list[l];
      k++;
    }
  }
 
  //남아있는 값들을 일괄 복사
  else{
    for(l=i; l<=mid; l++){
      sorted[k] = list[l];
      k++;
    }
  }
 
  //배열 sorted[]의 리스트를 배열 list[]로 재복사
  for(l=left; l<=right; l++){
    list[l] = sorted[l];
  }
}
```

## 퀵 정렬

- [ ]  배열을 단순하게 쪼개는 대신,병합 과정이 필요 없도록 한쪽의 배열에 포함된 수가 다른쪽에 배열의 수보다 항상 작도록 배열을 분할한다.
- [ ]  시간 복잡도:nlongn (병합 정렬보다 빠름)

```cpp
#include<iostream>
using namespace std;
 
void swap(int *arr,int a, int b){
    int tmp = arr[a];
    arr[a] = arr[b];
    arr[b] = tmp;
}
 
void myQuickSort(int *arr, int start, int end){
    int pivot = arr[start];
    int left = start+1;
    int right = end;
 
    while(left <= right){
 
        while(arr[left] < pivot){ left++; } //pivot보다 작은 경우는 건너뛰고 크거나 같은경우 멈춤
        while(arr[right] > pivot) { right--; } //pivot보다 큰 경우는 건너뛰고 작거나 같은경우 멈춤
 
        if(left <= right){ swap(arr, left, right); }
    }
 
 
    if(start < end){  //1개로 쪼개질때 까지
        swap(arr, start, right);   //pivot값과 arr[right] 값 swap
 
        myQuickSort(arr, start, right-1);  //앞 부분
        myQuickSort(arr, right+1, end);    //뒷 부분
    }
 
    return;
}
 
void outPut(int *arr, int len){
 
    for(int i=0; i<len ; i++){
        cout << "[" << arr[i] << "]";
    }
    cout << endl;
}
 
 
int main(void){
    int arr[7] = {5,3,7,6,2,1,4};
    
    outPut(arr, 7);
 
    //0 ~ len-1 범위.
    myQuickSort(arr, 0, 6);
 
    outPut(arr, 7);
 
    return 0;
}

```
